Programacion Funcional:
Curry y Uncurry: las funciones pueden devolver datos primitivos o hacer evaluacion parcial y devolver otras funciones
Curry:: ((a,b) -> c) -> (a -> (b -> c))
Curry f a b = f (a,b)
si bien es media anti intuitiva, f a b necesita de dos datos para ser procesada, f (a,b) solo necesita uno (la tupla)
Uncurry:: (a -> b -> c) -> ((a,b) -> c)
Uncurry f (a,b) = f a b
Notacion Lambda: para definir funciones anonimas, \ -> (no hace falta tiparla, pero hay que cuidar que sea correcta)
Composicion de Funciones: (.):: (a -> b) -> (c -> a) -> c -> b 
Map:: (a -> b) -> [a] -> [b] toma una funcion y se la aplica a una lista y te devuelve lista de aplicar esa funcion a todos los elementos de la lista.
Filter:: (a -> Bool) -> [a] -> [a]
Filter p (x:xs) = if p x then x : filter p xs else filter p xs
----------RECURSION ----------
Recursion estructural: el caso base devuelve un valor fijo Z, el caso recursivo usa una funcion sobre la cabeza de la lista y no usa el tail mas que para el llamado
recursivo
Foldr:: (a -> b -> b) -> [a] -> b
foldr f z [] = []
foldr f z x:xs = f x (foldr f z xs) 
Recursion primitiva: caso base devuelve valor fijo Z, caso recursivo puede referenciar a la cola de la lista ademas de en el llamado recursivo.
Recr:: (a -> [a] -> b ->  b) -> b -> [a] -> b
Recursion iterativa:: toma un acumulador y va actualizando su valor hasta llegar al caso base y lo devuelve actualizado.
foldl::(b -> a -> b) -> b -> [a] -> b
foldl _ ac [] = ac
foldl f ac x:xs = foldl f (f ac x ) xs
--------------------RAZONAMIENTO ECUACIONAL E INDUCCION ESTRUCTURAL-----------------------------------------------------
No hay tanto para decir de esto, no asumir nada, usar lemas y tener claro cuales y cuantos son los casos base e inductivos respectivamente.
La extensionalidad ayuda a separar en casos, listas es la vacia y la que tiene un head, booleanos True o False, Nat es Zero o Succ(Nat),... todo lo que sea una
propiedad debe enunciarse como P(q) con para todo Q, se pueden no escribir siempre pero aclarar que estan considerados los cuantificadores. La extensionalidad
funcional dice que dos funciones son iguales si para todo x::a, f,g:: a-> b, f x= g x
--------------------INTERPRETES-------------------------------------------------------------------------------
se definen distintos tipos de datos y hay que ver como hacer para que evaluar programas nos deje obtener distintos tipos de resultados como Nat, Booleanos, Expresiones etc.. 
usa mucho los cases of o va haciendo pattern matching con los tipos de datos. No vimos practica de esto asi que leer la teorica y chau.
----------------SISTEMAS DEDUCTIVOS Y DEDUCCION NATURAL-----------------------------------------------------------
Notacion: la implicacion asocia a derecha, las (∧, ∨) no son asociativos ni conmutativos. Eliminar el bottom seguido de la eliminacion de la negacion no ayuda casi nunca
Los principios clasicos solo cuando te dan permiso si no no. Fijarse que hay en el contexto que sirva para probar. A veces la eliminacion del O puede servir.
-----------------CALCULO LAMBDA------------------------------------------------------------------------------------
La sintaxis de los tipos: bool o τ → σ, el constructor de tipos → es asociativo a derecha.
Los terminos pueden ser: variables, abstracciones,aplicaciones,true,false,if M then N else P. Las aplicaciones asocian a izquierda y tienen mayor precedencia que la abstraccion
y el if.
Reglas de Tipado: consiste en, cuando se pide un juicio de tipado, poder dar los tipos que tienen los terminos en una expresion. Mirar las tablitas y dar las reglas de tipado solo de lo que piden
o es nuevo en el lambda extendido. Cuidar la unicidad de tipos
Semantica operacional: dice como se ejecuta un programa hasta llegar a un resultado.
Semantica small-step: ejecucion paso a paso. Un programa es un termino M tipable y cerrado(sin variables libres)
Juicios de evaluacion: M → N  donde M y N son programas
Hay que definir el conjunto de valores que seran posibles resultado de evaluar programas (true/false/abstraccion...)
Reglas de Congruencia: si M -> N, entonces tiene que no perder determinismo (no puede reducir por mas de una regla) ni prorgeso
(o bien M es un valor o bien existe N tal que M → N). si tengo por ej MP -> NP, y si la otra es VM -> VN no pueden 
algunos no ser valores
Reglas de computo: indican que termino o valor tiene como resultado una expresion si se hace una cierta operacion o se cumple
cierta precondicion en un if cosas asi.Si queremos que algo falle no le escribimos regla o explicitamos el fallo.
Cuando se trabaja con valores hay que hacer y aclarar la sustitucion en el termino que obtendremos de respuesta.
