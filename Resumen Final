Programacion Funcional:
Curry y Uncurry: las funciones pueden devolver datos primitivos o hacer evaluacion parcial y devolver otras funciones
Curry:: ((a,b) -> c) -> (a -> (b -> c))
Curry f a b = f (a,b)
si bien es media anti intuitiva, f a b necesita de dos datos para ser procesada, f (a,b) solo necesita uno (la tupla)
Uncurry:: (a -> b -> c) -> ((a,b) -> c)
Uncurry f (a,b) = f a b
Notacion Lambda: para definir funciones anonimas, \ -> (no hace falta tiparla, pero hay que cuidar que sea correcta)
Composicion de Funciones: (.):: (a -> b) -> (c -> a) -> c -> b 
Map:: (a -> b) -> [a] -> [b] toma una funcion y se la aplica a una lista y te devuelve lista de aplicar esa funcion a todos los elementos de la lista.
Filter:: (a -> Bool) -> [a] -> [a]
Filter p (x:xs) = if p x then x : filter p xs else filter p xs
----------RECURSION ----------
Recursion estructural: el caso base devuelve un valor fijo Z, el caso recursivo usa una funcion sobre la cabeza de la lista y no usa el tail mas que para el llamado
recursivo
Foldr:: (a -> b -> b) -> [a] -> b
foldr f z [] = []
foldr f z x:xs = f x (foldr f z xs) 
Recursion primitiva: caso base devuelve valor fijo Z, caso recursivo puede referenciar a la cola de la lista ademas de en el llamado recursivo.
Recr:: (a -> [a] -> b ->  b) -> b -> [a] -> b
Recursion iterativa:: toma un acumulador y va actualizando su valor hasta llegar al caso base y lo devuelve actualizado.
foldl::(b -> a -> b) -> b -> [a] -> b
foldl _ ac [] = ac
foldl f ac x:xs = foldl f (f ac x ) xs
--------------------RAZONAMIENTO ECUACIONAL E INDUCCION ESTRUCTURAL-----------------------------------------------------
No hay tanto para decir de esto, no asumir nada, usar lemas y tener claro cuales y cuantos son los casos base e inductivos respectivamente.
La extensionalidad ayuda a separar en casos, listas es la vacia y la que tiene un head, booleanos True o False, Nat es Zero o Succ(Nat),... todo lo que sea una
propiedad debe enunciarse como P(q) con para todo Q, se pueden no escribir siempre pero aclarar que estan considerados los cuantificadores. La extensionalidad
funcional dice que dos funciones son iguales si para todo x::a, f,g:: a-> b, f x= g x
--------------------INTERPRETES-------------------------------------------------------------------------------
se definen distintos tipos de datos y hay que ver como hacer para que evaluar programas nos deje obtener distintos tipos de resultados como Nat, Booleanos, Expresiones etc.. 
usa mucho los cases of o va haciendo pattern matching con los tipos de datos. No vimos practica de esto asi que leer la teorica y chau.
----------------SISTEMAS DEDUCTIVOS Y DEDUCCION NATURAL-----------------------------------------------------------
Notacion: la implicacion asocia a derecha, las (∧, ∨) no son asociativos ni conmutativos. Eliminar el bottom seguido de la eliminacion de la negacion no ayuda casi nunca
Los principios clasicos solo cuando te dan permiso si no no. Fijarse que hay en el contexto que sirva para probar. A veces la eliminacion del O puede servir.
-----------------CALCULO LAMBDA------------------------------------------------------------------------------------
La sintaxis de los tipos: bool o τ → σ, el constructor de tipos → es asociativo a derecha.
Los terminos pueden ser: variables, abstracciones,aplicaciones,true,false,if M then N else P. Las aplicaciones asocian a izquierda y tienen mayor precedencia que la abstraccion
y el if.
Reglas de Tipado: consiste en, cuando se pide un juicio de tipado, poder dar los tipos que tienen los terminos en una expresion. Mirar las tablitas y dar las reglas de tipado solo de lo que piden
o es nuevo en el lambda extendido. Cuidar la unicidad de tipos
Semantica operacional: dice como se ejecuta un programa hasta llegar a un resultado.
Semantica small-step: ejecucion paso a paso. Un programa es un termino M tipable y cerrado(sin variables libres)
Juicios de evaluacion: M → N  donde M y N son programas
Hay que definir el conjunto de valores que seran posibles resultado de evaluar programas (true/false/abstraccion...)
Reglas de Congruencia: si M -> N, entonces tiene que no perder determinismo (no puede reducir por mas de una regla) ni prorgeso
(o bien M es un valor o bien existe N tal que M → N). si tengo por ej MP -> NP, y si la otra es VM -> VN no pueden 
algunos no ser valores
Reglas de computo: indican que termino o valor tiene como resultado una expresion si se hace una cierta operacion o se cumple
cierta precondicion en un if cosas asi.Si queremos que algo falle no le escribimos regla o explicitamos el fallo.
Cuando se trabaja con valores hay que hacer y aclarar la sustitucion en el termino que obtendremos de respuesta.
---------------------Correspondecia Curry-Howard------------------------------------------------
Basicamente consiste en que se puede traducir las reglas de tipado a reglas de DN, se sacan los terminos y se dejan los tipos
el constructor de tipos σ → τ se puede leer como una implicacion σ ⇒ τ.Una formula puede tener mas de una prueba,
Corte(cut): es una afirmacion intermedio(lema) aunque no sea una subformula de la afirmacion final (metes un galerazo para
probar lo que tenes ganas basicamente) y queda de tarea demostrar el lema.Suele ser una introduccion del implica seguido
de una eliminacion del implica.Para eliminar el corte reemplazamos el termino que introdujimos y lo reemplazamos por su prueba
Conjuncion: es medio lo mismo, introducis las reglas de tipado dejas los tipos y pasas a DN. Los cortes son el elemento del par
que no estaba como afirmacion final.
Seguia pero me dio paja.
-------------------------INFERENCIA DE TIPOS-------------------------------------
Los terminos ahora no tienen tipos, hay que hacer el arbol de inferencia y ver si las variables ya existian en el contexto
o darles variables de tipo frescas. Seguir los pasos que te diga para el tipo de dato y sobre todo hacer el mgu y cuidar de
ver si falla o no, para ello podemos reducir el mgu con los siguientes pasos o nos indica si falla:
Delete-eliminacion trivial
Decompose (sobre todo funciones o cosas iguales a ambos lados y se quiere ver termino a termino)
Swap: te permite dar vuelta la unificacion, util sobre todo si vas a hacer una eliminacion y tenes las cosas al reves de lo que necesitas
Elim: siempre y cuando no rompa otras cosas, la eliminacion es como una sustitucion, "donde estaba este Xn ahora va este tipo 
ya que unificaron".
Clash: si no dan la cantidad exacta de terminos, si aparecen cosas tipo Nat ?= Bool, F(x1....) ?= G(...) los constructores
son distintos(las funciones) asi que no unificara.
Occur-Check: si Xn ?= t falla si Xn =/ t y Xn ocurre en t (basicamente X1 ?= X1 -> X2)
